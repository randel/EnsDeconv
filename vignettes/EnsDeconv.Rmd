---
title: "EnsDeconv"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{EnsDeconv}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Download packages
```{r}
# install devtools if necessary
if (!"devtools" %in% rownames(installed.packages())) {
  install.packages('devtools')
}

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

if (!"DeconRNASeq" %in% rownames(installed.packages())) {
  BiocManager::install("DeconRNASeq")
}

if (!"sva" %in% rownames(installed.packages())) {
  BiocManager::install("sva")
}



# install the EnsDeconv package
if (!"EnsDeconv" %in% rownames(installed.packages())) {
  devtools::install_github("randel/EnsDeconv",dependencies = T)
}

```

hspe package can be downloaded [here](https://gjhunt.github.io/hspe/hspe_0.1.tar.gz)





# Sample Code
Use two reference data, one deconvoluton methods, one normaliztaion, one transformation, one marker gene approach.

The testdata includes two different reference dataset (Nowakowski and Darmanis), and sample bulk data (n = 10).
```{r, message=FALSE}
library(foreach)
library(tidyverse)
library(EnsDeconv)
library(sparseMatrixStats)
library(scran)
testdata= EnsDeconv::testdata

params = get_params(data_type = "singlecell-rna", data_name = names(testdata$ref_list), n_markers = 50,Marker.Method = "t",TNormalization = "none",CNormalization = "none",dmeths = "CIBERSORT")

res = EnsDeconv(count_bulk = as.matrix(testdata$count_bulk), ref_list = testdata$ref_list, ncore = 4, parallel_comp = F, params = params,trueMet = "ROS")

#Use parallel computing
#res = EnsDeconv(count_bulk = as.matrix(testdata$count_bulk), ref_list = testdata$ref_list, ncore = 4, parallel_comp = T, params = params,trueMet = "ROS",outpath= '...')
```





```{r}
pheatmap::pheatmap(res[["EnsDeconv"]][["ensemble_p"]],cluster_rows = F,cluster_cols = F)
```

